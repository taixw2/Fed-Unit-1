## 第一节

### 工程化

#### 解决问题:

- 解决传统语法的弊端
    - 使用 ES6+ 语法
    - 提升 CSS 的编程性
- 解决无法直接使用模块化和组件化
    - 使用模块化,组件化提升模块的可维护性
- 解决重复劳动
    - 部署上线前的工作
    - 部署步骤流程化,持续化
- 统一代码风格,提高质量
- 解决需要依赖后端接口
    - mock 数据, 接口
- 解决整体依赖后端项目
    - 打包代码嵌入后端项目中

#### 工程化表现

- 创建阶段
    - 利用脚手架创建特定且统一的项目结构
    - 生成特定的文件
- 编码阶段
    - 统一的代码风格
    - 统一的编译\构建\打包
- 测试\预览阶段
    - webServer/Mock 减少后端依赖
    - LiveReload/HMR 热更新
    - SourceMap 
- 提交阶段
    - git hooks
    - Lint-Staged
- 部署阶段
    - CI/CD
    - 自动发布

#### 工具在工程化中的作用

工具只是用来落地工程化的一种手段

**工程化步骤**
    - 文件的组织结构
    - 源代码的开发范式
    - 如何做前后端分离(ajax, 中间层)
    ...


![](../images/tool.png)

提前做好整体规划,在选择相应的工具来做对应的落地

**集成化工程方案**
- 目录结构
- 热更新
- 自动编译
- 校验等等

**node**

前端的工业革命,前端工程化由 node 推动

- 脚手架开发
- 自动构建打包系统
- 模块化打包
- 项目代码规范
- 自动化部署

#### 总结:

node 让推动前端的工程化进程, 工程化包括前端开发中设计的所有流程, 从约定项目结构到打包上线部署等等

## 第二节

#### 脚手架

脚手架一般用户创建项目结构, 以及约定规范等

- 相同的目录结构
- 相同的开发范式
- 相同的模块依赖
- 相同的工具配置
- 相同的基础代码

根据信息提供特定的项目结构以及约定

#### yeoman, Plop

yeoman 需要依赖特定的 generater,  
创建基础的模块,而不是完整的一套代码结构可以采用 sub-generator, 比如说 eslint, readme 等等,在原有的 generator 加上

**使用步骤**

1. 明确需求
2. 找到合适的 generator
3. 全局范围安装 generator
4. 通过 Yo 查找全局范围的 generator
5. 通过交互式命令填写选项
6. 生成所需的项目结构

不同的 generator 生成不同的项目结构, 同时也可以自定义项目结构

**generator 基础结构**

- generators
    - app
        - index.js
- package.json

模块名词必须是 generator-<name>

**代码**

- [generator-sample](../codes/generator-sample/package.json)

**Plop**

用于自动创建重复文件

**总结**

脚手架通过询问项目的一些配置, 再结合一些模板文件, 从而生成对应的项目结构

## 第三节

构建就是将源代码转化成能够在生产过程中运行的代码, 作用是能够在编码过程中使用最新的特性,并且构建后在运行环境中直接运行

#### 常用的自动化构建工具

1. Grunt
2. Gulp
3. FIS

想 webpack 是模块打包工具,并不是自动化构建工具,

#### Grunt

它的构建过程是基于临时文件的, 也就是说每一个步骤都需要进行文件的读写操作

#### Gulp

他的构建过程是基于内存的, 所以速度比较快

#### Fis

大而权的工具
