## 简答题

### 第一题：

- 结果：打印出 10
- 原因：通过 var 声明的变量不会产生块级作用域，在执行 a[6]() 时，此时的 i 已经变成了 10， 所以打印 10

### 第二题：
- 结果：抛出异常
- 原因：{}（大括号）会生成块级作用域，在 `if` 中通过 `let` 声明的 `tmp` 会在当前块级作用域中形成一个“暂时性死区”，所以此时无法在声明前访问 `tmp`

### 第三题：
- 结果：Math.min(...arr)
- 原因: 通过 `Math.min` 可以求出一组数据中的最小值，利用 ES6 的解构(...)， 将数组中的每一个元素作为参数传入给 `Math.min`

### 第四题：
- `var`: 是 `ECMAScript 2015` 前用来声明变量的方式，这种声明方式有：“变量提升”、“可重复声明” 等特点
- `let`: 是 `ECMAScript 2015` 之后出现的声明变量的方式，声明的变量是：“可变的”，“不可重复声明”，“只作用于当前作用域” 等特点
- `const`: 与 `let` 同时期出现的方式，与其类似，区别是：“`const` 声明的变量是不可变的”，这种不可变对于“引用类型”的变量来说，是指它的引用地址不变，但是它的属性依然可以修改

### 第五题：
- 结果： 打印 20
- 原因： 方法 obj.fn() 被调用的时候， `fn` 方法的 `this` 值被指向为 `obj`, `fn` 中调用 `setTimeout` 传入的是一个箭头函数，箭头函数中的执行上下文（this）声明时所处的上下文决定，所以在箭头函数中的 `this` 也指向为 `obj`, 故而打印 20

### 第六题：
- 作为内部的一些钩子，比如实现 `Symbol.iterator` 的对象能够被迭代器 `for of` 迭代
- 作为私有属性、内部变量
- 避免键冲突，如 redux 的 action type

### 第七题：
- 浅拷贝： 对于基础类型，拷贝数据的值，对于属性值是引用类型，则拷贝数据的引用地址
- 深拷贝： 基础类型与浅拷贝一致，对于属性值是引用类型，则拷贝引用类型中的成员属性，其中需要避免循环引用问题，解决方法有开辟一个空间（如 `set`） 保存已经拷贝过的引用类型的数据，在拷贝前判读是否已经拷贝过该数据

### 第八题：
- JS 是单线程的语言，目的是避免同时处理 DOM 元素的问题等，对于耗时任务 JS 的做法之一是：等待 JS 线程不再繁忙的时候再处理， 比如 Ajax 的异步、setTimout 等宿主环境提供的 API，可以让 JS 在一段时间后执行逻辑，
- Event Loop: 在 JS 中维护一个主要的任务队列，其中任务分为同步的与异步的，同步的任务被直接加在任务队列中，异步的则会先将任务加在异步队列中，等待主线程空闲的时候，再放到主任务队列等待主线程执行，这个过程是循环不断的，所以这种运行机制叫 Event Loop
- 宏任务：宏任务就是在   
- 微任务：
