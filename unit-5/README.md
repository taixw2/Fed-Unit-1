## 课程笔记

[课程笔记](./notes)

## 1、当我们点击按钮的时候动态给 data 增加的成员是否是响应式数据，如果不是的话，如果把新增成员设置成响应式数据，它的内部原理是什么。

```javascript
let vm = new Vue({
 el: '#el'
 data: {
  o: 'object',
  dog: {}
 },
 method: {
  clickHandler () {
   // 该 name 属性是否是响应式的
   this.dog.name = 'Trump'
  }
 }
})
```
1. Vue2.x 是基于 Object.defineProperty 进行数据劫持， 新增的成员是**无法成为响应式数据**, 
    1. Object.defineProperty 的特性是只能对对象的成员进行劫持
    2. Vue 在初始化后会遍历 data，将所有成员挂载在 Vue 实例上进行劫持，所以之后在实例上新增的成员**不能成为响应式数据**
    3. Vue 劫持的成员的操作，实际是操作私有 _data/$data，data 通过 Observer 转换成响应式数据，其中也是通过 Object.defineProperty 进行劫持
    4. 在已有的成员上新增成员，如果是对象，那么这个对象也会成为响应式数据，在已经被劫持的成员上新增成员，是能够被操作并且转换成响应式数据的
2. 如果需要对新增成员设置成响应式
    1. 前面所述，data 转成响应式是基于遍历对象成员，最后将成员变成响应式
    2. 创建辅助函数，如 Vue.set(target, key, value)， 原理如下：
        1. Vue 实例代理了所有 data 中的成员，在实例中需要访问新增成员，需要把新增成员也代理到 Vue 实例上, Object.defineProperty(target, key, { xxx })
        2. Vue 实例中代理的成员实例是访问私有的 data 对象， 在私有 data 对象上也需要将新的成员加上, Object.defineProperty(target._data, key, { xxx })
    3. 利用 Proxy 对对象进行劫持
3. Vue3.0 是基于 Proxy 进行数据劫持， Proxy 是对对象进行劫持，Object.defineProperty 是对成员进行劫持，所以此时新增的成员也是响应式数据



## 2、请简述 Diff 算法的执行过程

虚拟 DOM 通过使用 js 对象模拟 DOM 的结构，让修改 js 对象直接映射在 DOM 上，能够避免直接与底层的操作， 与渲染层解耦，只要实现了对应接口的平台， 都能够使用虚拟 DOM 进行界面搭建。  
虚拟 DOM 中，为了拥有更好的性能，减少对底层 API 的操作，采用 diff 算法进行优化  
diff 算法为了权衡效率与复杂性上，只对同级的元素进行对比，以下是 diff 算法的基本步骤

1. 当对比两个节点是，如果两个节点是相同节点 (key, sel 相同), 则根据新节点更新 DOM 元素的状态并继续判断他们的子节点， 否则直接用新节点替换旧节点
2. 如果新子节点是文本节点， 并且与旧子节点不同，则清除旧子节点，将新的文本设置到真实 DOM 中
3. 如果新子节点存在，而旧子节点不存在则创建新的节点
4. 如果新子节点不存在，而旧子节点存在则删除旧的节点
5. 如果新子节点存在，并且旧子节点也存在，且他们不同，则需要进行对比，对新旧子节点对比的过程如下:
    - 对新旧子节点采用四个指针进行遍历，分别对象，新节点开始，旧节点开始，新节点结束，旧节点结束
    - 如果新节点开始于旧节点开始是相同节点，则进入第一步， 并且继续对比下一个新旧节点
    - 如果不相等，则判断新结束节点与旧结束节点是否相同，相同则进入第一步，并且继续对比前一个新旧节点
    - 如果新旧结束节点不相等，则判断新结束节点与旧开始节点是否相等，相同则进入第一步，并且把把元素插入当前旧结束节点末尾
        - 注意点
        - 把当前元素移动到结束节点后面，因为当前已经是新结束节点
        - 继续对比下一个旧开始节点，与前一个新结束节点
    - 如果旧开始节点与新结束节点不相等，则判断新开始节点与旧结束节点是否相等，相等则进入下一步，
        - 与上一个对比类型
        - 把当前元素移动到当前旧开始节点之前， 因为当前判断的是新开始节点
        - 继续对比下一个新开始节点，与前一个旧结束节点
    - 如果以上对比完了，还有新节点未处理，这需要继续
        - 找出所有旧节点的标识 key + 这个元素所在的索引
        - 找出与当前节点匹配的 key，继续判断是否相同节点，如果没有找到，则认为是新节点，并且创建
        - 如果 key 相同，但是不是相同的 el， 则也被认为是新节点

## 3、模拟 VueRouter 的 hash 模式的实现，实现思路和 History 模式类似，把 URL 中的 # 后面的内容作为路由的地址，可以通过 hashchange 事件监听路由地址的变化。

[代码地址](./codes/routers/)

### 实现思路
1. history 结合 HTML5 的 history API 对路由进行控制， history api 允许修改浏览器地址栏， 并且不向后端发送请求，以及监听 popstate 事件， 观察用户点击前进后退
2. hash 模式结合 location.hash 以及 hashchange 对 hash 进行监听， 当 hash 变化后更新节点

## 4、在模拟 Vue.js 响应式源码的基础上实现 v-html 指令，以及 v-on 指令。

[代码地址](./codes/vue-reactive/)

### 实现思路
1. 在已有的基础上实现 v-html, 只需要在原来的指令上新增一个 htmlUpdater，以及他的处理方式就是讲字符串通过 inserHtml 插入到节点
2. v-on 用于在事件上监听方法，由于原来的指令只处理了插值表达式，所以需要做以下处理
    1. 把事件放在 methods 成员中，类似实例上的一个命名空间
    2. 把所有成员挂载在实例上并且通过 bind 绑定当前实例，方便其他方法使用
    3. 区分插值表达式与事件处理
    4. 与插值表达式一样，找到对应的事件，然后哦将该事件挂载在节点上
    5. 详细代码见： [代码地址](./codes/vue-reactive/src/directive.ts)

## 5、参考 Snabbdom 提供的电影列表的示例，利用Snabbdom 实现类似的效果，如图：

![效果图](./images/effect.png)

暂未实现

